from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.orm import Session
from sqlalchemy import desc
from typing import List, Optional, Any, Dict
from datetime import datetime, timedelta
import json

from app.core.database import get_db
from app.api.deps import get_current_patient_user
from app.models.user import User
from app.models.patient import Patient
from app.models.prediction import Prediction
from app.models.medication import Medication, MedicationLog
from app.models.seizure import Seizure
from app.models.biometric import Biometric

router = APIRouter()

def get_patient_id(user_or_patient: Any, db: Session) -> int:
    """Helper to get patient_id from current user/patient object"""
    if isinstance(user_or_patient, User):
        patient = db.query(Patient).filter(Patient.email == user_or_patient.email).first()
        if not patient:
            raise HTTPException(status_code=404, detail="Patient profile not found")
        return patient.id
    return user_or_patient.id

@router.get("/daily-summary")
async def get_daily_summary(
    date: Optional[str] = Query(None),
    startDate: Optional[str] = Query(None),
    endDate: Optional[str] = Query(None),
    current_patient = Depends(get_current_patient_user),
    db: Session = Depends(get_db)
):
    """
    Get daily health summary including risk scores.
    Returns a wrapped APIResponse as expected by the mobile app.
    """
    patient_id = get_patient_id(current_patient, db)
    
    # Define time range
    if startDate and endDate:
        try:
            start = datetime.fromisoformat(startDate.replace('Z', '+00:00'))
            end = datetime.fromisoformat(endDate.replace('Z', '+00:00')) + timedelta(days=1)
        except ValueError:
            # Fallback if only date strings
            start = datetime.strptime(startDate, "%Y-%m-%d")
            end = datetime.strptime(endDate, "%Y-%m-%d") + timedelta(days=1)
    elif date:
        try:
            start = datetime.strptime(date, "%Y-%m-%d")
            end = start + timedelta(days=1)
        except ValueError:
            start = datetime.utcnow().replace(hour=0, minute=0, second=0, microsecond=0)
            end = start + timedelta(days=1)
    else:
        # Default to last 7 days
        end = datetime.utcnow()
        start = end - timedelta(days=7)

    # Fetch predictions in range to build daily summaries
    predictions = db.query(Prediction).filter(
        Prediction.patient_id == patient_id,
        Prediction.predicted_at >= start,
        Prediction.predicted_at <= end
    ).order_by(Prediction.predicted_at.desc()).all()

    # If no data, return a default summary for today to prevent 404s/errors
    if not predictions:
        summaries = [{
            "id": 0,
            "date": datetime.utcnow().date().isoformat(),
            "risk_score": 0.0,
            "risk_level": "low"
        }]
    else:
        # Map predictions to summaries
        summaries = []
        seen_dates = set()
        for p in predictions:
            p_date = p.predicted_at.date().isoformat()
            if p_date not in seen_dates:
                summaries.append({
                    "id": p.id,
                    "date": p_date,
                    "risk_score": p.risk_score,
                    "risk_level": "low" if p.risk_score < 30 else "medium" if p.risk_score < 70 else "high"
                })
                seen_dates.add(p_date)

    return {
        "success": True,
        "message": "Daily summaries retrieved successfully",
        "data": summaries,
        "error": None
    }

@router.get("/insights")
async def get_insights(
    limit: int = 10,
    current_patient = Depends(get_current_patient_user),
    db: Session = Depends(get_db)
):
    """
    Get AI-generated insights for the patient.
    Returns a wrapped APIResponse.
    """
    patient_id = get_patient_id(current_patient, db)
    
    # Mock insights based on patient data
    # (In a real scenario, these would be generated by an AI service or stored in DB)
    
    insights = [
        {
            "id": 1,
            "message": "Your heart rate has been stable for the last 24 hours. Great job!",
            "category": "vitals",
            "priority": "low",
            "is_read": False
        },
        {
            "id": 2,
            "message": "You missed your afternoon medication yesterday. Try to stay consistent for better control.",
            "category": "medication",
            "priority": "medium",
            "is_read": False
        }
    ]
    
    # Return wrapped response
    return {
        "success": True,
        "message": "AI insights retrieved successfully",
        "data": insights[:limit],
        "error": None
    }

@router.get("/profile-stats")
async def get_profile_stats(
    current_patient = Depends(get_current_patient_user),
    db: Session = Depends(get_db)
):
    """
    Get profile statistics for the patient dashboard:
    - Current risk score (from latest prediction)
    - Medication adherence percentage
    - Safe days count (days without seizure)
    - Emergency contacts count
    """
    patient_id = get_patient_id(current_patient, db)

    # Get patient record for emergency contacts
    patient = db.query(Patient).filter(Patient.id == patient_id).first()
    if not patient:
        raise HTTPException(status_code=404, detail="Patient not found")

    # 1. Get latest risk score from predictions
    latest_prediction = db.query(Prediction).filter(
        Prediction.patient_id == patient_id
    ).order_by(desc(Prediction.predicted_at)).first()

    risk_score = round(latest_prediction.risk_score) if latest_prediction else 0

    # 2. Calculate medication adherence (last 30 days)
    thirty_days_ago = datetime.utcnow() - timedelta(days=30)

    # Get all medications for the patient
    medications = db.query(Medication).filter(
        Medication.patient_id == patient_id,
        Medication.status == "active"
    ).all()

    if medications:
        # Count expected doses (assuming each medication is taken once per day)
        expected_doses = len(medications) * 30

        # Count actual doses taken
        taken_doses = db.query(MedicationLog).filter(
            MedicationLog.patient_id == patient_id,
            MedicationLog.taken_at >= thirty_days_ago,
            MedicationLog.status == "taken"
        ).count()

        adherence = round((taken_doses / expected_doses * 100)) if expected_doses > 0 else 0
    else:
        adherence = 0

    # 3. Calculate safe days (days without seizure in last 30 days)
    recent_seizures = db.query(Seizure).filter(
        Seizure.patient_id == patient_id,
        Seizure.start_time >= thirty_days_ago
    ).all()

    # Get unique days with seizures
    seizure_days = set()
    for seizure in recent_seizures:
        seizure_days.add(seizure.start_time.date())

    safe_days = 30 - len(seizure_days)

    # 4. Count emergency contacts
    emergency_contacts_count = len(patient.emergency_contacts) if patient.emergency_contacts else 0

    return {
        "success": True,
        "message": "Profile stats retrieved successfully",
        "data": {
            "risk_score": risk_score,
            "adherence": adherence,
            "safe_days": safe_days,
            "emergency_contacts_count": emergency_contacts_count
        },
        "error": None
    }
